{
  "problems": [
    {
      "id": "alternating_sum_inversion",
      "description": "Given an array of integers and a target sum, find the minimum number of inversions (i.e., swapping adjacent elements) required to transform the array into an alternating sum sequence that equals the target sum. An alternating sum sequence is one where the sum of elements at even indices minus the sum of elements at odd indices equals the target sum. The input array may contain duplicate elements and may be empty.",
      "function_signature": "def alternating_sum_inversion(arr: list[int], target_sum: int) -> int:",
      "baseline_tests": [
        "assert alternating_sum_inversion([1, 2, 3, 4], 2) == 1",
        "assert alternating_sum_inversion([5, 5, 5, 5], 0) == 0",
        "assert alternating_sum_inversion([1, 3, 5, 7], -10) == -1",
        "assert alternating_sum_inversion([], 10) == -1",
        "assert alternating_sum_inversion([10, 10, 10, 10], 20) == -1"
      ],
      "reference_solution": "def alternating_sum_inversion(arr: list[int], target_sum: int) -> int:\n    \"\"\"\n    This function calculates the minimum number of inversions required to transform the input array into an alternating sum sequence that equals the target sum.\n\n    Args:\n    arr (list[int]): The input array of integers.\n    target_sum (int): The target sum of the alternating sum sequence.\n\n    Returns:\n    int: The minimum number of inversions required, or -1 if it's impossible to achieve the target sum.\n    \"\"\"\n\n    # Base case: If the array is empty, it's impossible to achieve the target sum.\n    if not arr:\n        return -1\n\n    # Initialize variables to store the minimum number of inversions and the current sum.\n    min_inversions = float('inf')\n    current_sum = 0\n\n    # Iterate over all possible permutations of the array.\n    from itertools import permutations\n    for perm in permutations(arr):\n        # Calculate the alternating sum of the current permutation.\n        alt_sum = sum(perm[::2]) - sum(perm[1::2])\n\n        # If the alternating sum equals the target sum, calculate the number of inversions.\n        if alt_sum == target_sum:\n            inversions = 0\n            for i in range(len(perm) - 1):\n                if perm[i] > perm[i + 1]:\n                    inversions += 1\n            # Update the minimum number of inversions.\n            min_inversions = min(min_inversions, inversions)\n\n    # If no permutation achieves the target sum, return -1.\n    if min_inversions == float('inf'):\n        return -1\n    else:\n        return min_inversions",
      "difficulty": "easy",
      "tags": [
        "array manipulation"
      ]
    },
    {
      "id": "palindrome_substring_rearrangement",
      "description": "Given a string, find the longest substring that can be rearranged into a palindrome. A palindrome is a string that reads the same backward as forward. If there are multiple substrings of the same maximum length, return the one that appears first in the original string.\nThe function should return the length of the longest substring and the substring itself.",
      "function_signature": "def palindrome_substring_rearrangement(s: str) -> tuple[int, str]:",
      "baseline_tests": [
        "assert palindrome_substring_rearrangement(\"abcba\") == (5, \"abcba\")",
        "assert palindrome_substring_rearrangement(\"abccba\") == (6, \"abccba\")",
        "assert palindrome_substring_rearrangement(\"abcdefgh\") == (1, \"a\")",
        "assert palindrome_substring_rearrangement(\"aa\") == (2, \"aa\")",
        "assert palindrome_substring_rearrangement(\"\") == (0, \"\")"
      ],
      "reference_solution": "def palindrome_substring_rearrangement(s: str) -> tuple[int, str]:\n    \"\"\"\n    Find the longest substring that can be rearranged into a palindrome.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    tuple[int, str]: A tuple containing the length of the longest substring and the substring itself.\n    \"\"\"\n    \n    def can_be_palindrome(substring: str) -> bool:\n        \"\"\"\n        Check if a substring can be rearranged into a palindrome.\n\n        Args:\n        substring (str): The substring to check.\n\n        Returns:\n        bool: True if the substring can be rearranged into a palindrome, False otherwise.\n        \"\"\"\n        char_count = {}\n        for char in substring:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        odd_count = 0\n        for count in char_count.values():\n            if count % 2 != 0:\n                odd_count += 1\n            if odd_count > 1:\n                return False\n        return True\n\n    max_length = 0\n    max_substring = \"\"\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if can_be_palindrome(substring) and len(substring) > max_length:\n                max_length = len(substring)\n                max_substring = substring\n\n    return max_length, max_substring",
      "difficulty": "easy",
      "tags": [
        "string processing"
      ]
    },
    {
      "id": "merge_overlapping_segments_with_priorities",
      "description": "Given a list of segments with priorities, where each segment is defined by a start and end point, merge overlapping segments and assign the maximum priority to the merged segment. If two segments have the same priority, the segment with the earlier start point should be considered first. The goal is to minimize the number of merged segments while maintaining the correct priority order.",
      "function_signature": "def merge_overlapping_segments_with_priorities(segments: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:",
      "baseline_tests": [
        "assert merge_overlapping_segments_with_priorities([(1, 3, 1), (2, 4, 2), (5, 7, 3)]) == [(1, 4, 2), (5, 7, 3)]",
        "assert merge_overlapping_segments_with_priorities([(1, 2, 1), (3, 4, 2), (5, 6, 3)]) == [(1, 2, 1), (3, 4, 2), (5, 6, 3)]",
        "assert merge_overlapping_segments_with_priorities([(1, 5, 1), (2, 3, 2), (4, 6, 3)]) == [(1, 6, 3)]",
        "assert merge_overlapping_segments_with_priorities([]) == []",
        "assert merge_overlapping_segments_with_priorities([(1, 10, 1), (2, 3, 1), (4, 5, 1), (6, 7, 1)]) == [(1, 10, 1)]"
      ],
      "reference_solution": "def merge_overlapping_segments_with_priorities(segments: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n    \"\"\"\n    Merge overlapping segments and assign the maximum priority to the merged segment.\n    \n    Args:\n    segments: A list of segments, where each segment is a tuple of (start, end, priority).\n    \n    Returns:\n    A list of merged segments, where each segment is a tuple of (start, end, priority).\n    \"\"\"\n    \n    # Handle edge case where input list is empty\n    if not segments:\n        return []\n    \n    # Sort segments by start point and then by priority\n    segments.sort(key=lambda x: (x[0], -x[2]))\n    \n    # Initialize merged segments with the first segment\n    merged = [segments[0]]\n    \n    # Iterate over the remaining segments\n    for current in segments[1:]:\n        # Get the last merged segment\n        last_merged = merged[-1]\n        \n        # Check if the current segment overlaps with the last merged segment\n        if current[0] <= last_merged[1]:\n            # Merge the current segment with the last merged segment\n            merged[-1] = (last_merged[0], max(last_merged[1], current[1]), max(last_merged[2], current[2]))\n        else:\n            # Add the current segment to the list of merged segments\n            merged.append(current)\n    \n    return merged",
      "difficulty": "medium",
      "tags": [
        "data structures"
      ]
    },
    {
      "id": "temporal_graph_reachability",
      "description": "Given a temporal graph, where each edge has a timestamp, determine if it's possible to reach a target node from a source node within a certain time limit. The graph is represented as a list of edges, where each edge is a tuple of (source, target, timestamp). The function should return the minimum time required to reach the target node, or -1 if it's not possible.",
      "function_signature": "def temporal_graph_reachability(edges: list[tuple[int, int, int]], source: int, target: int, time_limit: int) -> int:",
      "baseline_tests": [
        "assert temporal_graph_reachability([(1, 2, 1), (2, 3, 2), (1, 3, 3)], 1, 3, 4) == 3",
        "assert temporal_graph_reachability([(1, 2, 1), (2, 3, 2), (1, 3, 3)], 1, 3, 2) == -1",
        "assert temporal_graph_reachability([(1, 2, 1), (2, 3, 2)], 1, 3, 3) == 3",
        "assert temporal_graph_reachability([], 1, 2, 10) == -1",
        "assert temporal_graph_reachability([(1, 2, 10), (2, 3, 10)], 1, 3, 20) == 20"
      ],
      "reference_solution": "import heapq\n\ndef temporal_graph_reachability(edges, source, target, time_limit):\n    graph = {}\n    for u, v, t in edges:\n        if u not in graph:\n            graph[u] = []\n        graph[u].append((v, t))\n\n    queue = [(0, source)]\n    visited = set()\n\n    while queue:\n        time, node = heapq.heappop(queue)\n        if node == target:\n            return time\n        if node in visited or time > time_limit:\n            continue\n        visited.add(node)\n        if node in graph:\n            for neighbor, timestamp in graph[node]:\n                if time + timestamp <= time_limit:\n                    heapq.heappush(queue, (time + timestamp, neighbor))\n\n    return -1",
      "difficulty": "medium",
      "tags": [
        "graph algorithms"
      ]
    }
  ]
}